# [7장] 코드를 작성하고 실행하기

## 내용 요약 
### 아이템 53. 타입스크립트 기능보다는 ECMAScript 기능을 사용하기

js의 업데이트 된 추가 기능들은 ts 초기 버전에서 독립적으로 개발했던 기능과 호환성 문제를 발생시켰다. 이로 인하여 ts는,
신규 기능을 그대로 채택하고 독립적으로 개발한 초기 ts 버전과 호환성을 포기하는 전략을 사용하였다. 결국 ts는 타입 기능만
발전시키는 것으로 원칙을 세웟다.

그러나 이 원칙이 세워지기 전 이미 사용되던 몇가지 기능이 있다.

** 이 기능들은 사용하지 않는 편을 권장하므로 대충만 익히겠다.

* 열거형 (enum)
  + enum 대신 유니온을 사용하는 것이 좋다.
  + 숫자 열거형
    ```
    enum Flavor {
        VANILLA = 0,
        CHOCO = 1,
    }
    ```

  + 상수 열거형
    ```
    const enum Flavor {
        VANILLA = 0,
        CHOCO = 1,
    }
    ```
    보통의 열거형과 달리 런타임에 완전히 제거됩니다.
    preserveConstEnums 플래그를 설정해주지 않으면
    컴파일러는 Flavor.CHOCO을 0으로 바꿔버린다.

  + 문자열 열거형
    ```
    enum Flavor {
        VANILLA = 'vanilla',
        CHOCO = 'choco',
    }
    let choco = Flavor.CHOCO
    ```
    문자열 열거형은 구조적 타이핑<sup>1</sup>이 아닌 명목적 타이핑을 사용합니다.
    ```
    let choco = Flavor.CHOCO; 
        choch = 'vanilla'; 
    // '"vanilla"' 형식은 'Flavor' 형식에 할당될 수 없습니다.
    ```

* 매개변수 속성
  + 사용방법
    ```
    // 일반적
    class Person {
        name: string
        constructor(name: string) {
            this.name = name
        }
    }
    // 매개변수 속성
    class Person {
        constructor(public name: string) {}
        //          ~~~~~~~~~~~ 매개변수 속성
    }
    ```
  + 문제점
    - 일반적으로 ts 컴파일은 타입 제거가 이루어지므로 코드가 줄지만, 매개변수 속성은 코드가 늘어나는 문법입니다.
    - 매개변수 속성이 ts 관점에서는 사용되지 않는 것처럼 보인다.
    - 매개변수 속성과 일반 속성을 섞어서 사용하면 클래스 설계가 혼란스러워진다.
* 트리플 슬래시 임포트 
  + ECMAScript 2015 스타일의 모듈 (import, export)를 사용하는 것은 권장한다.
* 데코레이터
  + 앵귤러를 사용중이거나 애너테이션이 필요한 프레임워크를 사용하고 있는 게 아니라면 사용하지 않는것이 좋다.

### 아이템 54. 객체를 순회하는 노하우

다음 예제는 오류를 발생시킨다.
그 이유와 오류를 제거 할 수 있는 방법을 제시하시오.
```
type ABC = {
  a: string;
  b: string;
  c: number;
}

function foo(abc: ABC) {
  for (const k in obj) {
    const v = obj[k] // any 타입
  }
}
```

* 원인: 타입스크립트는 구조적 타이핑으로 인하여 obj 객체에 또 다른 속성이 추가 될 수 있다고 추론하였기에, 예제의 변수 k의 타입이 string으로 선택하였기 때문입니다.

* 해결 방안
  + k의 타입을 구체적으로 명시해 준다.
    ```
    function foo(abc: ABC) {
      let k: keyof ABC;
      for (k in abc) {
        const v = abc[k] 
        // v의 타입이 string|number으로 제한되므로, obj의 값에 다른 타입의 값이 들어갈 경우 오류가 발생 할 수있다.
      }
    }

    foo({a:'1', b:'2', c:3, d: new Date()}); // 정상
    ```

  + Object.entries를 사용한다.
    ```
    function foo(abc: ABC) {
      for (const [k,v] of Object.entries(abc)) {
        k // string
        v // any
      }
    }
    ```


### 아이템 55. DOM 계층 구조 이해하기
- 일반적으로 타입 단언문은 지양해야 하지만, DOM 관련해서는 단언문을 사용해도 좋다.
- 이벤트 핸들러를 인라인 함수로 제공하면, ts는 더 많은 문맥 정보를 사용 가능하게 된다.
- DOM 계층의 구조의 차이점과, 구체적인 이벤트 타입의 차이점을 알아야한다.

### 아이템 56. 정보를 감추는 목적으로 private 사용하지 않기

- ts의 protected, private 같은 접근 제어자는 컴파일 후 제거되므로 공개 규칙을 강제할 수 없다. 오해하지 말자.
- 대신 클로저를 이용하자.
  
- 접두사 #
  <img width="468" alt="스크린샷 2022-08-06 오후 8 35 26" src="https://user-images.githubusercontent.com/59957559/183247257-568ea967-446a-4907-8edb-21b3d61d6011.png">
  - 아직 표준화 되지 않았다.
  - 타입 체크와 런타임 모두에서 비공개로 만들 수 있다.
  - 클로저와는 다르게, 클래스 메서드나 동일 클래스의 개별 인스턴스끼리 접근이 가능합니다.

### 아이템 57. 소스맵을 사용하여 타입스크립트 디버깅하기

- sourceMap 옵션을 true로 설정 할 경우 컴파일 시 소스맵 파일(.js.map)도 함께 생성되는데, 소스맵이 있으면 디버거에서 생성된 js대신 원본 타입스크립트 소스를 사용 할 수 있다.
- product 환경에서 소스맵이 유출되지 않는지 확인해야한다.
- 

## 단어 설명

1. 명목적 타이핑: 구조적 타이핑은 구조가 같으면 할당이 허용되는 반면, 명목적 타이핑은 타입의 이름이 같아야 할당이 허용됩니다.

## 질문 사항

### 아이템 53
- 일반적으로 ts 컴파일은 타입 제거가 이루어지므로 코드가 줄지만, 매개변수 속성은 코드가 늘어나는 문법입니다.
- 매개변수 속성이 ts 관점에서는 사용되지 않는 것처럼 보인다.

### 아이템 54
- for-in 루프에서 k가 string 키를 가지게 된다면 프로토타입 오염의 가능성을 의심해 봐야 한다.  

### 아이템 56
- 클로저와는 다르게, 클래스 메서드나 동일 클래스의 개별 인스턴스끼리 접근이 가능합니다.